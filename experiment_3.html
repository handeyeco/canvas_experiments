<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>Canvas Tutorial</title>

    <style>
        html,
        body {
            background: white;
        }

        #container {
            background: white;
            position: absolute;
            left: 50%;
            top: 50%;
        }
        canvas {
          border: 1px solid;
        }
    </style>
</head>

<body>
    <div id="container"></div>
</body>

<script>

var container,
    canvas,
    ctx,
    cord =[],
    bounds, mouse = {},
    rows = 100,
    cols = 100,
    cubeDim = 10,
    cubeCount = rows * cols,
    date,
    manual = false,
    triCount = 0,
    canvasDim = cubeDim * rows,
    triList = [];

function Tri(i, x, y) {
  this.i = i;
  // 90 degree angle
  this.x = x;
  this.y = y;
  this.active = false;
  this.opacity = 1;
  this.even = i % 2 == 0;

  if (this.even) {
    // Coord to the right
    this.a = x + cubeDim;
    this.b = y;
    // Coord to the bottom
    this.m = x;
    this.n = y + cubeDim;
  } else {
    // Coord to the left
    this.a = x - cubeDim;
    this.b = y;
    // Coord to the top
    this.m = x;
    this.n = y - cubeDim;
  }
}

Tri.prototype.activate = function () {
  this.active = true;
  this.opacity = 1;
}

function initialize() {
  container = document.getElementById('container');
  canvas = document.createElement('canvas');
  ctx = canvas.getContext('2d');

  canvas.width = canvas.height = canvasDim;
  container.style.marginLeft = Math.round(canvasDim * -0.5) + 'px';
  container.style.marginTop = Math.round(canvasDim * -0.5) + 'px';

  for (var i = 0; i < cubeCount; i++) {
    cord[0] = cubeDim * (i % cols);
    cord[1] = Math.floor(i / cols) * cubeDim;
    triList.push(new Tri(triCount++, ...cord));

    cord[0] += cubeDim;
    cord[1] += cubeDim;
    triList.push(new Tri(triCount++, ...cord));
  }

  //Add mousemove to container
  container.addEventListener('mousemove', function(e) {
      manual = true;
      bounds = container.getBoundingClientRect();
      mouse.x = e.clientX - bounds.left;
      mouse.y = e.clientY - bounds.top;
  });

  container.appendChild(canvas);

  window.requestAnimationFrame(step);
}

function step() {
  triList.forEach((tri) => {
    if (manual) {
      if (tri.even) {
        if ((mouse.x > tri.x && mouse.x < tri.x + cubeDim / 2) && (mouse.y > tri.y && mouse.y < tri.y + cubeDim / 2)) {
          tri.activate()
        }
      } else {
        if ((mouse.x < tri.x && mouse.x > tri.x - cubeDim / 2) && (mouse.y < tri.y && mouse.y > tri.y - cubeDim / 2)) {
          tri.activate();
        }
      }
    }
    else {
      date = new Date();
      date = date.getMilliseconds();
      if (date > 2 && tri.i % date == 0) {
        tri.activate();
      }
    }

    if (tri.opacity <= 0.04) {
      tri.active = false;
    }

    if (tri.active) {
      // console.log(tri.i);
      ctx.clearRect(tri.x, tri.y, cubeDim, cubeDim);

      if (date % tri.i == 42) {
        ctx.fillStyle = `rgba(94,121,42,${tri.opacity})`;
      } else if (date % tri.i == 87) {
        ctx.fillStyle = `rgba(121,43,94,${tri.opacity})`;
      } else {
        ctx.fillStyle = `rgba(43,94,121,${tri.opacity})`;
      }

      ctx.beginPath();
      ctx.moveTo(tri.x, tri.y);
      ctx.lineTo(tri.a, tri.b);
      ctx.lineTo(tri.m, tri.n);
      ctx.fill();

      tri.opacity -= 0.001;
    } else {
      ctx.fillStyle = `white`;
      ctx.fillRect(tri.x, tri.y, cubeDim, cubeDim);
    }
  });

  window.requestAnimationFrame(step);
}

initialize();

</script>

</html>
